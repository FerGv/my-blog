# ES6+ caracter√≠sticas

Con la versi√≥n de ECMAScript 2015 (ES6) y todas las que siguieron, Javascript dio un giro total e incorpor√≥ muchas nuevas caracter√≠sticas que mejoraron y arreglaron el lenguaje. Hoy tratar√© de mostrarte algunas de las m√°s relevantes pero te recomiendo revisar este [repositorio](https://github.com/tc39/proposals) para estar al tanto de las novedades en JS.

## [Funciones flecha](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

Se incorpor√≥ una nueva forma de crear funciones (m√°s limpia a mi parecer üòÖ). Te muestro c√≥mo:

```js
function funcionTradicional() {
  console.log('Hola Mundo');
}

const funcionFlecha = () => {
  console.log('Hola Mundo');
};
```

Como puedes ver, se elimin√≥ la palabra `function` y se agreg√≥ el s√≠mbolo de flecha `=>` (de ah√≠ su nombre). Pero en algunos casos, la sintaxis puede ser todav√≠a m√°s compacta:

```js
// Declaraci√≥n tradicional
const suma = (a, b) => {
  return a + b;
};

// Equivalente a:
const suma = (a, b) => a + b;
```

Cuando tu funci√≥n es de una sola l√≠nea, puedes eliminar las llaves `{}`. Y si lo √∫nico que hace es retornar un valor, tambi√©n puedes eliminar la palabra `return`. Es m√°s, si solo recibes un par√°metro, tambi√©n puedes eliminar los par√©ntesis.

<!-- prettier-ignore -->
```js
[1, 2, 3].forEach(numero => console.log(numero));
```

::: tip
Aunque es v√°lido no poner par√©ntesis, seg√∫n la [gu√≠a de estilos de Airbnb](https://github.com/airbnb/javascript), es buena pr√°ctica siempre escribirlos. Depende mucho del estilo que uses para programar pero siempre es bueno seguir est√°ndares y gu√≠as de estilos predefinidas.
:::

En lo personal, me gusta bastante esta nueva forma de crear funciones y procuro usarla en la mayor√≠a de casos. Pero ten cuidado, no suplen a las funciones tradicionales en todo, deja te muestro en ejemplito:

```js
const persona = {
  nombre: 'Fer',
  saludarTradicional: function() {
    console.log(`Hola, mi nombre es ${this.nombre}`);
  },
  saludarFlecha: () => {
    console.log(`Hola, mi nombre es ${this.nombre}`);
  },
};

persona.saludarTradicional();
// -> 'Hola, mi nombre es Fer'
persona.saludarFlecha();
// -> 'Hola, mi nombre es undefined'
```

Esto tiene que ver con el contexto que toma cada tipo de funci√≥n, **las funciones tradicionales toman el contexto en el que son ejecutadas, mientras que las funciones flecha toman el contexto externo en el que son declaradas**. Revisa esta [pregunta de StackOverflow](https://es.stackoverflow.com/questions/1799/cuando-usar-una-funci%C3%B3n-flechaarrow-function-en-vez-de-una-funci%C3%B3n-com%C3%BAn) para m√°s informaci√≥n.

::: tip
Tambi√©n puedes usar la sintaxis reducida al declarar funciones tradicionales dentro de objetos o clases.

```js
const persona = {
  nombre: 'Fer',
  saludar() {
    console.log(`Hola, mi nombre es ${this.nombre}`);
  },
};

class Persona {
  nombre = 'Fer';

  saludar() {
    console.log(`Hola, mi nombre es ${this.nombre}`);
  }
}
```

M√°s adelante veremos acerca de [clases](#clases).
:::

## [Interpolaci√≥n](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Template_literals)

Ahora podemos interpolar variables en cadenas de texto con los backticks `` ` `` (es el s√≠mbolo de acento grave, checa la distribuci√≥n de tu teclado para saber c√≥mo obtenerlo).

```js
const nombre = 'Fer';

// Concatenaci√≥n
console.log('Hola ' + nombre);

// Interpolaci√≥n
console.log(`Hola ${nombre}`);
```

Esto nos ayuda a escribir c√≥digo mucho m√°s claro y evitar esos molestos s√≠mbolos de `+` entre las cadenas de texto. Tambi√©n nos permiten escribir cadenas multil√≠nea. Un caso muy com√∫n es cuando queremos agregar un elemento HTML mediante JS.

<!-- prettier-ignore -->
```js
const estudiante = 'Fer';
const listaEstudiantes = document.querySelector('ul');

// Concatenaci√≥n
listaEstudiantes.insertAdjacentHTML('beforeend',
  '<li>' +
    '<a href="http://midominio.com/estudiantes/' + estudiante + '">' +
      estudiante +
    '</a>' +
  '</li>'
);

// Interpolaci√≥n
listaEstudiantes.insertAdjacentHTML('beforeend',
  `<li>
    <a href="http://midominio.com/estudiantes/${estudiante}">
      ${estudiante}
    </a>
  </li>`
);
```

Definitivamente mucho mejor y limpio ü§ìüëå.

::: tip
[insertAdjacentHTML](https://developer.mozilla.org/es/docs/Web/API/Element/insertAdjacentHTML) es la nueva forma de agregar un elemento HTML escribiendo su estructura como cadena de texto. Si est√°s familiarizado con [jQuery](https://jquery.com/), ser√≠a el equivalente a [append](https://api.jquery.com/append/) y [prepend](https://api.jquery.com/prepend/).

Por cierto, **ya no uses jQuery, por favor ü•∫**.
:::

## [Desestructuraci√≥n](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

La `desestructuraci√≥n` nos permite obtener valores de un arreglo u objeto y asignarlos a variables en una misma sentencia.

```js
// ---------------- Antes ----------------
const alumnos = ['Fernando', 'Anah√≠'];
const alumno1 = alumnos[0];
const alumno2 = alumnos[1];

const persona = { nombre: 'Fer', edad: 23 };
const nombre = persona.nombre;
const edad = persona.edad;

// ---------------- Ahora ----------------
const [alumno1, alumno2] = ['Fernando', 'Anah√≠'];
// -> Fernando, Anah√≠

const { nombre, edad } = { nombre: 'Fer', edad: 23 };
// -> Fer, 23
```

Tambi√©n puedes declarar las variables primero, pero debes cambiar a `let`.

```js
let alumno1, alumno2, nombre, edad;
[alumno1, alumno2] = ['Fernando', 'Anah√≠'];
// Debes agrupar esta sentencia en par√©ntesis para evitar errores de sintaxis.
// Esto se debe a que las llaves representan bloques de c√≥digo.
({ nombre, edad } = { nombre: 'Fer', edad: 23 });
```

Puedes usar el [operador rest](#par√°metros-rest) para guardar en un arreglo u objeto el resto de valores.

```js
const [alumno1, ...restoAlumnos] = ['Fernando', 'Anah√≠', 'Pedro', 'Laura'];
// -> Fernando, [Anah√≠, Pedro, Laura]

const { nombre, ...restoPersona } = {
  nombre: 'Fer',
  edad: 23,
  profesion: 'desarrollador',
  g√©nero: 'masculino',
};
// -> Fer, { edad: 23, profesion: 'desarrollador', g√©nero: 'masculino' }
```

Para los objetos puedes cambiar el nombre de la propiedad que est√°s desestructurando. Solo escribe dos puntos y el nuevo nombre.

```js
const { nombre: miNombre, edad: miEdad } = { nombre: 'Fer', edad: 23 };
console.log(miNombre, miEdad);
// -> Fer, 23
```

Tambi√©n puedes asignar valores por defecto en caso de que el objeto no tenga la propiedad que buscas o no exista ese √≠ndice en el arreglo.

```js
const [alumno1, alumno2 = 'Anah√≠'] = ['Fernando'];
// -> Fer, Anah√≠

const { nombre: miNombre, edad: miEdad = 30 } = { nombre: 'Fer' };
// -> Fer, 30
```

::: tip
Ahora puedes hacer un intercambio de valores f√°cilmente. Olv√≠date de declarar una variable auxiliar como en los viejos tiempos.

```js
let a = 1;
let b = 2;
[a, b] = [b, a];
console.log(a, b);
// -> 2, 1
```

:::

## [Operador spread](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

Con esta nueva sintaxis podemos "expandir" un arreglo u objeto dentro de otro arreglo, objeto o funci√≥n. Lo que har√° el **operador spread (`...`)** es tomar cada item o propiedad y los copiar√° donde t√∫ le indiques.

```js
const grupoA = ['Carlos', 'Pedro'];
const grupoB = ['Fernando', ...grupoA];
// -> ['Fernando', 'Carlos', 'Pedro']

const persona = { nombre: 'Anah√≠' };
const estudiante = { ...persona, clase: 'Programaci√≥n' };
// -> { nombre: 'Anah√≠', clase: 'Programaci√≥n' }

const numeros = [3, 5];
const suma = (a, b) => a + b;
suma(...numeros);
// -> 8
```

Con esto puedes copiar f√°cilmente un arreglo u objeto.

```js
const numeros = [1, 2, 3];
const numerosCopia = [...numeros];

const orden = { id: 1, total: 10 };
const ordenCopia = { ...orden };
```

::: warning
En caso de que tengas arreglos u objetos anidados, sus referencias se mantendr√°n y cualquier cambio afectar√° a los originales. Revisa mi art√≠culo sobre [referencias](../reference-vs-value/) para saber m√°s.
:::

## [Par√°metros rest](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Functions/rest_parameters)

Los `par√°metros rest` usan la misma sintaxis que el [operador spread](#operador-spread): los tres puntos (...). Pero en este caso se usa para indicar que se recibir√° un n√∫mero indefinido de par√°metros en una funci√≥n. Veamos c√≥mo:

```js
function suma(...numeros) {
  return numeros.reduce((total, numero) => total + numero, 0);
}

suma(1, 2, 3, 4);
// -> 10
```

Los argumentos se guardan en un arreglo, el cual **posee todos los m√©todos y propiedades de arreglos (map, filter, reduce, etc.)**. Hago √©nfasis en esto porque la forma antigua de resolver este problema era con **arguments**, el cual es un [Array-like](https://stackoverflow.com/questions/29707568/javascript-difference-between-array-and-array-like-object), es decir, comparte cierta similitud con los arreglos pero no es uno, por lo que no puedes usar m√©todos como map.

Este es el mismo ejemplo pero con **arguments**. Como ves, **arguments** no es definido como par√°metro, simplemente accedemos a √©l dentro la funci√≥n. Bastante extra√±o a mi parecer. **Ya no lo uses üòÖ.**

```js
function suma() {
  let total = 0;

  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }

  return total;
}

suma(1, 2, 3, 4);
// -> 10
```

## [Par√°metros por defecto](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Functions/Default_parameters)

## [Promesas](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise)

## [Async/await](https://developer.mozilla.org/es/docs/Learn/JavaScript/Asynchronous/Async_await)

## [Encadenamiento opcional](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Optional_chaining)

## [Operador nullish](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator)

(Lo siento, no encontr√© la documentaci√≥n oficial en espa√±ol üò¨)

## [M√≥dulos](https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Modules)

## [Comas finales (trailing commas)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas)

(Lo siento, no encontr√© la documentaci√≥n oficial en espa√±ol x2 üò¨)

Te dejo esta [lectura](https://medium.com/@nikgraf/why-you-should-enforce-dangling-commas-for-multiline-statements-d034c98e36f8)(en ingl√©s üò¨) y esta [pregunta de StackOverflow](https://es.stackoverflow.com/questions/202727/como-funcionan-los-trailing-commas-en-javascript) para m√°s informaci√≥n.

## [Map](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Map)

## [Set](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Set)

## [Clases](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/class)

## [Atributos privados](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Classes/Private_class_fields)

<Disqus />
